#Requires -Version 5\n<#\n.SYNOPSIS\n    Builds the Live Transcription application using PyInstaller for Windows.\n\n.DESCRIPTION\n    This script packages the Python application into a single executable and then (optionally)\n    creates a signed Windows installer using a tool like Inno Setup (signing part is a placeholder).\n\n    Prerequisites:\n    1. Python 3.8+ installed and in PATH.\n    2. PyInstaller installed: pip install pyinstaller\n    3. (Optional for Installer) Inno Setup installed and in PATH (or specify path).\n    4. (Optional for Signing) A valid code signing certificate and signtool.exe.\n\n.PARAMETER OutputDirectory\n    The directory where the build artifacts (dist, build, executable, installer) will be placed.\n    Default: \'.\\dist_pkg\'\n\n.PARAMETER AppVersion\n    The version number for the application (e.g., \"1.0.0\").\n    Default: \"1.0.0\"\n\n.PARAMETER SignExecutable\n    Switch to attempt signing the executable and installer. Requires SignTool and a certificate.\n    Default: $false\n\n.PARAMETER CertificatePath\n    Path to the .pfx code signing certificate file. Required if -SignExecutable is used.\n\n.PARAMETER CertificatePassword\n    Password for the code signing certificate. Required if -SignExecutable is used.\n\n.EXAMPLE\n    .\\build.ps1 -OutputDirectory .\\MyAppRelease -AppVersion \"1.2.3\"\n\n.EXAMPLE\n    .\\build.ps1 -SignExecutable -CertificatePath \"C:\\certs\\mycert.pfx\" -CertificatePassword \"mypass\"\n#>\n\nparam(\n    [string]$OutputDirectory = \".\\dist_build\",\n    [string]$AppVersion = \"1.0.0\",\n    [switch]$SignExecutable,\n    [string]$CertificatePath,\n    [string]$CertificatePassword,\n    [string]$InnoSetupCompilerPath = \"C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe\" # Default Inno Setup path\n)\n\n$ErrorActionPreference = \"Stop\"\nSet-StrictMode -Version Latest\n\n# --- Script Variables ---\n$ScriptName = \"LiveTranscriptionApp\"\n$MainScript = \"main.py\"\n$IconPath = \".\\assets\\app_icon.ico\" # Optional: Create an assets folder with an icon\n$DistPath = Join-Path -Path $OutputDirectory -ChildPath \"dist\"\n$BuildPath = Join-Path -Path $OutputDirectory -ChildPath \"build_pyinstaller\"\n$FinalExecutableName = \"${ScriptName}_v${AppVersion}.exe\"\n$InstallerName = \"${ScriptName}_v${AppVersion}_setup.exe\"\n\n# --- Pre-flight Checks ---\nWrite-Host \"Starting build process for $ScriptName v$AppVersion...\"\n\n# Check for Python\nif (-not (Get-Command python -ErrorAction SilentlyContinue)) {\n    Write-Error \"Python not found in PATH. Please install Python and add it to PATH.\"\n    exit 1\n}\n\n# Check for PyInstaller\nif (-not (Get-Command pyinstaller -ErrorAction SilentlyContinue)) {\n    Write-Error \"PyInstaller not found. Please install it by running: pip install pyinstaller\"\n    exit 1\n}\n\nif ($SignExecutable) {\n    if (-not (Test-Path $CertificatePath -PathType Leaf)) {\n        Write-Error \"Certificate file not found at $CertificatePath. Required for signing.\"\n        exit 1\n    }\n    if ([string]::IsNullOrEmpty($CertificatePassword)) {\n        Write-Error \"CertificatePassword is required when -SignExecutable is specified.\"\n        exit 1\n    }\n    # Check for SignTool (usually part of Windows SDK)\n    # A more robust check would search standard SDK locations.\n    if (-not (Get-Command signtool -ErrorAction SilentlyContinue)) {\n        Write-Warning \"signtool.exe not found in PATH. Executable signing will likely fail.\"\n        Write-Warning \"Ensure Windows SDK is installed and signtool.exe is in your PATH.\"\n    }\n}\n\n# --- Create Output Directory ---\nif (-not (Test-Path $OutputDirectory)) {\n    Write-Host \"Creating output directory: $OutputDirectory\"\n    New-Item -ItemType Directory -Path $OutputDirectory -Force | Out-Null\n} else {\n    Write-Host \"Cleaning previous build directories in $OutputDirectory...\"\n    if (Test-Path $DistPath) { Remove-Item -Recurse -Force $DistPath }\n    if (Test-Path $BuildPath) { Remove-Item -Recurse -Force $BuildPath }\n}\n\n# --- PyInstaller Build ---\nWrite-Host \"Running PyInstaller to package the application...\"\n\n$pyinstallerArgs = @(\n    \"--noconfirm\",\n    \"--onedir\", # Creates a directory. For a single file use --onefile, but --onedir is often more reliable.\n    # \"--onefile\", # Creates a single executable. Can have slower startup.\n    \"--windowed\", # Use for GUI applications to hide console window.\n    # \"--console\", # Use for CLI applications or for debugging.\n    \"--name $($ScriptName)\",\n    \"--distpath $($DistPath)\",\n    \"--workpath $($BuildPath)\",\n    # Add data files and hidden imports if necessary\n    # Example: \"--add-data \'$($PSScriptRoot)\\config.yml:.\'\",\n    # Example: \"--add-data \'$($PSScriptRoot)\\assets:assets\'\", # If you have an assets folder\n    # Whisper models are large and downloaded at runtime by default. \n    # If you bundle a model, it significantly increases package size.\n    # \"--hidden-import=\'soundcard\'\", # PyInstaller might miss some imports\n    # \"--hidden-import=\'pyyaml\'\",\n    # \"--hidden-import=\'openai_whisper\'\",\n    # \"--hidden-import=\'azure.cognitiveservices.speech\'\",\n    # \"--hidden-import=\'numpy\'\", \n    # \"--hidden-import=\'tkinter\'\"\n    # PyInstaller usually auto-detects these with recent versions, but explicit is safer.\n\n    # Add hook paths if custom hooks are needed for libraries like sounddevice/soundcard\n    # \"--additional-hooks-dir=\'$($PSScriptRoot)\\hooks\'\" # Create a \'hooks\' dir with hook-yourlib.py\n    # For soundcard/sounddevice, you might need to ensure C libraries (portaudio) are handled.\n    # Usually, pip installing the wheel for sounddevice includes necessary binaries.\n\n    # For Whisper, ffmpeg is a runtime dependency if not installed globally.\n    # Consider bundling ffmpeg or instructing users to install it.\n    # Bundling ffmpeg: download static build, add with --add-binary\n    # \"--add-binary \'.\\ffmpeg\\bin\\ffmpeg.exe:ffmpeg\'\", \n    # \"--add-binary \'.\\ffmpeg\\bin\\ffprobe.exe:ffmpeg\'\"\n    # Then in your Python code, you might need to point Whisper to this bundled ffmpeg.\n    # os.environ[\"PATH\"] += os.pathsep + os.path.join(sys._MEIPASS, \"ffmpeg\") if hasattr(sys, \"_MEIPASS\") else \"\"\n)\n\nif (Test-Path $IconPath -PathType Leaf) {\n    $pyinstallerArgs += \"--icon=$IconPath\"\n    Write-Host \"Using icon: $IconPath\"\n} else {\n    Write-Warning \"Application icon not found at $IconPath. Using default icon.\"\n}\n\n$pyinstallerArgs += \"$($PSScriptRoot)\\$MainScript\"\n\n\n# Dynamically discover and add hidden imports for STT engines to be safe\n# This is a more robust way than manually listing them if they change.\n$requiredLibs = @(\n    \"soundcard\", \"yaml\", \"whisper\", \"azure.cognitiveservices.speech\", \"numpy\", \"tkinter\", \"logging\", \"queue\", \"threading\", \"datetime\", \"jiwer\", \"soundfile\"\n    # Add more if other direct/indirect dependencies are often missed by PyInstaller\n)\nforeach ($lib in $requiredLibs) {\n    # Check if the lib is actually used by analyzing imports (basic check)\n    # A more sophisticated check would parse AST or use importlib_metadata\n    # For now, just add common ones known to be problematic or critical.\n    $pyinstallerArgs += \"--hidden-import=$lib\"\n}\n\n# Add data for soundcard if it has specific DLLs/SOs that need bundling and are not picked up.\n# This can be very specific to the library version and how it\'s installed.\n# Example for a hypothetical DLL needed by soundcard:\n# if (Test-Path (Join-Path $env:CONDA_PREFIX \"Library\\bin\\portaudio_x64.dll\")) { # Example for conda env\n#    $pyinstallerArgs += \"--add-binary \'\" + (Join-Path $env:CONDA_PREFIX \"Library\\bin\\portaudio_x64.dll\") + \":.\'\"\n# }\n\nWrite-Host \"PyInstaller command: pyinstaller $($pyinstallerArgs -join \' \')\"\ntry {\n    Invoke-Expression \"pyinstaller $($pyinstallerArgs -join \' \')\"\n    Write-Host \"PyInstaller packaging completed successfully.\" -ForegroundColor Green\n} catch {\n    Write-Error \"PyInstaller packaging failed: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Rename the executable in the dist folder (PyInstaller creates a folder with app name)\n$SourceExeDir = Join-Path -Path $DistPath -ChildPath $ScriptName\n$SourceExePath = Join-Path -Path $SourceExeDir -ChildPath \"$($ScriptName).exe\"\n$FinalExePath = Join-Path -Path $SourceExeDir -ChildPath $FinalExecutableName\n\nif (Test-Path $SourceExePath) {\n    Rename-Item -Path $SourceExePath -NewName $FinalExecutableName\n    Write-Host \"Executable renamed to: $FinalExecutableName\"\n} else {\n    Write-Error \"PyInstaller did not create the expected executable at $SourceExePath\"\n    exit 1\n}\n\n# Copy config.yml to the distribution directory beside the executable\n$ConfigFileName = \"config.yml\"\n$SourceConfigPath = Join-Path -Path $PSScriptRoot -ChildPath $ConfigFileName\n$DestConfigPath = Join-Path -Path $SourceExeDir -ChildPath $ConfigFileName\nif (Test-Path $SourceConfigPath) {\n    Copy-Item -Path $SourceConfigPath -Destination $DestConfigPath\n    Write-Host \"Copied $ConfigFileName to $SourceExeDir\"\n} else {\n    Write-Warning \"$ConfigFileName not found at $SourceConfigPath. The application might need it at runtime.\"\n}\n\n# --- Code Signing (Optional) ---\nif ($SignExecutable) {\n    Write-Host \"Attempting to sign the executable: $FinalExePath ...\"\n    # Signtool command (adjust timestamp server URL if needed)\n    # Common timestamp server: http://timestamp.digicert.com or http://timestamp.comodoca.com/rfc3161\n    $timestampServer = \"http://timestamp.digicert.com\"\n    $signtoolArgs = \"sign /f \`\"$CertificatePath\`\" /p \`\"$CertificatePassword\`\" /tr \`\"$timestampServer\`\" /td sha256 /fd sha256 \`\"$FinalExePath\`\"\"\n    \n    try {\n        Write-Host \"Executing: signtool $signtoolArgs\"\n        Invoke-Expression \"signtool $signtoolArgs\"\n        Write-Host \"Executable signed successfully: $FinalExePath\" -ForegroundColor Green\n    } catch {\n        Write-Error \"Failed to sign executable: $($_.Exception.Message)\"\n        Write-Warning \"Make sure signtool.exe is in your PATH and certificate details are correct.\"\n        # Decide if this is a critical failure for your build process\n    }\n} else {\n    Write-Host \"Skipping executable signing.\"\n}\n\n# --- Installer Creation (Example using Inno Setup - Optional) ---\nWrite-Host \"Installer creation step (placeholder/optional).\"\n# This section is a placeholder for creating an installer (e.g., with Inno Setup)\n# You would typically create an Inno Setup Script (.iss file) first.\n\n$CreateInstaller = $false # Set to $true to enable Inno Setup example\n$InnoSetupScript = Join-Path -Path $PSScriptRoot -ChildPath \"${ScriptName}_setup.iss\" # Example ISS file name\n\nif ($CreateInstaller) {\n    if (-not (Test-Path $InnoSetupCompilerPath -PathType Leaf)) {\n        Write-Warning \"Inno Setup Compiler (ISCC.exe) not found at $InnoSetupCompilerPath. Skipping installer creation.\"\n    } elseif (-not (Test-Path $InnoSetupScript -PathType Leaf)) {\n        Write-Warning \"Inno Setup Script ($InnoSetupScript) not found. Skipping installer creation.\"\n        Write-Warning \"You need to create an .iss script to define how the installer is built.\"\n        # Create a very basic Inno Setup script for demonstration\n        $iss_content = @\"\n[Setup]\nAppName=$ScriptName\nAppVersion=$AppVersion\nDefaultDirName={autopf}\\$ScriptName\nDefaultGroupName=$ScriptName\nOutputBaseFilename=$(Split-Path $InstallerName -Leaf -Resolve)\nOutputDir=$(Split-Path (Join-Path $OutputDirectory $InstallerName) -Parent -Resolve)\nCompression=lzma\nSolidCompression=yes\nWizardStyle=modern\nPrivilegesRequired=admin ; or use `lowest` if no admin rights needed by app\n\n[Tasks]\nName: \"desktopicon\"; Description: \"{cm:CreateDesktopIcon}\"; GroupDescription: \"{cm:AdditionalIcons}\"; Flags: unchecked\n\n[Files]\nSource: \"$FinalExePath\"; DestDir: \"{app}\"; Flags: ignoreversion\nSource: \"$DestConfigPath\"; DestDir: \"{app}\"; Flags: ignoreversion\n; Add other files/directories from $SourceExeDir (e.g., assets, DLLs) as needed\n; Source: \"$SourceExeDir\\*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs createallsubdirs\n\n[Icons]\nName: \"{group}\\$ScriptName\"; Filename: \"{app}\\$FinalExecutableName\"\nName: \"{group}\\{cm:UninstallProgram,$ScriptName}\"; Filename: \"{uninstallexe}\"\nName: \"{autodesktop}\\$ScriptName\"; Filename: \"{app}\\$FinalExecutableName\"; Tasks: desktopicon\n\n[Run]\nFilename: \"{app}\\$FinalExecutableName\"; Description: \"{cm:LaunchProgram,$ScriptName}\"; Flags: nowait postinstall skipifsilent\n\"@\n        Set-Content -Path $InnoSetupScript -Value $iss_content -Encoding UTF8\n        Write-Host \"Generated a sample Inno Setup script: $InnoSetupScript. Please review and customize it.\"\n    }\n    \n    if ((Test-Path $InnoSetupCompilerPath -PathType Leaf) -and (Test-Path $InnoSetupScript -PathType Leaf)) {\n        Write-Host \"Creating installer using Inno Setup...\"\n        $isccArgs = \"\`\"$InnoSetupScript\`\"\"\n        try {\n            Invoke-Expression \"& \`\"$InnoSetupCompilerPath\`\" $isccArgs\"\n            Write-Host \"Installer created successfully: $(Join-Path $OutputDirectory $InstallerName)\" -ForegroundColor Green\n\n            # Sign the installer if requested\n            if ($SignExecutable) {\n                $InstallerPath = Join-Path -Path $OutputDirectory -ChildPath $(Split-Path $InstallerName -Leaf -Resolve)\n                if (Test-Path $InstallerPath) {\n                    Write-Host \"Attempting to sign the installer: $InstallerPath ...\"\n                    $signtoolInstallerArgs = \"sign /f \`\"$CertificatePath\`\" /p \`\"$CertificatePassword\`\" /tr \`\"$timestampServer\`\" /td sha256 /fd sha256 \`\"$InstallerPath\`\"\"\n                    Invoke-Expression \"signtool $signtoolInstallerArgs\"\n                    Write-Host \"Installer signed successfully: $InstallerPath\" -ForegroundColor Green\n                } else {\n                    Write-Warning \"Installer file not found at $InstallerPath for signing.\"\n                }\n            } else {\n                Write-Host \"Skipping installer signing.\"\n            }\n        } catch {\n            Write-Error \"Inno Setup compilation failed: $($_.Exception.Message)\"\n        }\n    }\n} else {\n    Write-Host \"Skipping installer creation (feature not enabled in script). Edit `$CreateInstaller` in script to enable.\"\n}\n\nWrite-Host \"Build process finished.\"\nWrite-Host \"Packaged application is in: $SourceExeDir\"\nif ($CreateInstaller -and (Test-Path (Join-Path $OutputDirectory $InstallerName))) {\n    Write-Host \"Installer is at: $(Join-Path $OutputDirectory $InstallerName)\"\n} elseif ($CreateInstaller) {\n    Write-Host \"Installer creation was attempted but may have failed or was skipped.\"\n}\n\n# --- End of Script ---\n 